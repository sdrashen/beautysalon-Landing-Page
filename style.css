/*RESET*/

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

a {
    text-decoration: none;
}

ul {
    list-style: none;
}


/*Tira as imgs do tamanho original e as adapta ao 100%*/

img {
    width: 100%;
    height: auto;
}


/* VARIABLES */

:root {
    --header-height: 4.5rem;
    /*font-size: 100% - Since 16px is by default the font-size, applying 100% to it means the same and 100% becomes a reference*/
    /* colors */
    --hue: 159;
    /* HSL color mode */
    --base-color: hsl(var(--hue) 36% 57%);
    --base-color-second: hsl(var(--hue) 65% 88%);
    --base-color-alt: hsl(var(--hue) 57% 53%);
    --title-color: hsl(var(--hue) 41% 10%);
    --text-color: hsl(0 0% 46%);
    --text-color-light: hsl(0 0% 98%);
    --body-color: hsl(0 0% 98%);
}


/* BASE */

html {
    scroll-behavior: smooth;
}

body {
    font: 400 1rem 'DM Sans', sans-serif;
    color: var(--text-color);
    background: var(--body-color);
    /* webkit é um prefixo (vendor prefixer) que depende do navegador.
    Se o navegador é um tipo webkit (o chrome é)  então ele aplica a propriedade (font-smoothing: antialiased;) que está habilitada nele. Ela ñ está habilitada em todos mas no chrome está. */
    -webkit-font-smoothing: antialiased;
}

.title {
    font: 700 1.875rem 'Poppins', sans-serif;
    color: var(--title-color);
    -webkit-font-smoothing: auto;
}

.button {
    background-color: var(--base-color);
    color: var(--text-color-light);
    height: /*56 / 16*/
    3.5rem;
    display: inline-flex;
    /*Esse display habilita o align-items*/
    /* O display inline sozinho pega apenas a area do texto, o display block pega margin e height do container. O inline-block pega apenas o height do cont. */
    align-items: center;
    padding: 0 2rem;
    border-radius: 0.25rem;
    font: 500 1rem 'DM Sans, sans-serif';
    /*Essa transition é referente ao hover*/
    transition: background 0.3s;
}

.button:hover {
    background-color: var(--base-color-alt);
}

.divider-1 {
    height: 1px;
    background: linear-gradient( 270deg, hsla(var(--hue), 36%, 57%, 1), hsla(var(--hue), 65%, 88%, 0.34));
}

.divider-2 {
    /*Here we invert the line divider. Now it's from dark to light*/
    height: 1px;
    background: linear-gradient( 270deg, hsla(var(--hue), 65%, 88%, 0.34), hsla(var(--hue), 36%, 57%, 1));
}


/*rem = "root em" will always get a relative reference. In this case, it will always use as reference the font-size, that is 100%. So here we have 16 * 4.5 = 72px. 72px is the height of the header in the design on Figma*/


/* LAYOUT */


/*container, grid e section se repetiram tantas vezes que é interessante organiza-los aqui em cima*/

.container {
    margin: 0 1.5rem;
}

.grid {
    display: grid;
    /*Esse display aqui não mud nada mas habilita outras funcionalidades como o gap. */
    gap: 2rem;
}

.section {
    padding: 5rem 0;
}

.section .title {
    margin-bottom: 1rem;
}

.section header {
    margin-bottom: 4rem;
}

.section header strong {
    color: var(--base-color);
}

#header {
    border-bottom: 1px solid #e4e4e4;
    margin-bottom: 2rem;
    display: flex;
    /*Esse position é pra fazer o header ficar parado. E ele também habilita o z-index*/
    position: fixed;
    /*top e left 0 aqui para garantir*/
    top: 0;
    left: 0;
    z-index: 100;
    /*100 para fazer o header ficar bem acima de tudo*/
    background-color: var(--body-color);
    /*Perceba que os itens foram lá pra cima porque o postion fixed top e left 0 cria uma nova camada e os elementos que estavam respeitando a altura por causa do nav agora não respeitam mais porque eles sobem. Todos eles estavam respeitando a linha mas quando um sai de contexto e vai pra cima todos os outros os seguem tomando o seu posicionamento*/
    /*Esse width 100% e o do #home .text p é para conter a rolagem horizontal. Mesmo assim não estava funcioanndo, então foi retirado o max-width 100% do #home .text p e o 100% do container, aí sim a rolagem horizontal parou*/
    width: 100%;
}


/*Adicionando esse margin ao main e juntamente com o height do nav, os elementos que mudram por causa do position fixed top e left 0 voltam ao normal e o header fica lá fixo.*/

main {
    margin-top: calc(var(--header-height) + 2rem);
    /*Há mais espaço do topo(32px). O calc faz uma função (pode ser soma, mult, div, sub), nesse caso ele adiciona esse 2rem (32/16). Agora o topo ali recebe o valor da var header-height + 2rem*/
}


/*LOGO*/

.logo {
    font: 700 1.31rem 'Poppins', sans-serif;
    color: var(--title-color);
}

.logo span {
    color: var(--base-color);
}


/*NAVIGATION*/

nav {
    height: var(--header-height);
    /*72/16 = 4,5*/
    /* O height vai ficar aqui porque a altura que o nav tiver será a mesma do header. A vantagem de deixar aqui é que aqui já tem o display flex.  */
    display: flex;
    justify-content: space-between;
    align-items: center;
    /*O pai desse elemento nav que é o header tem width 100% e o filho, nav, por causa do display felx não estava pegando esses 100% (e também talvez porque o pai está com os posicionamentos mexidos e tal, assim aqueles 3 pontinhos (que mais tarde viram o menu estilo hamburguer, ficaram grudados na palavra beautysalon. Para consertar isso tem que add width 100% ao nav também. */
    width: 100%;
}

nav ul li {
    text-align: center;
}

nav ul li a {
    /*Esse transition aqui tem efeito no hover abaixo*/
    transition: 0.2s;
    position: relative;
}

nav ul li a:hover {
    color: var(--base-color);
}

nav ul li a::after {
    content: '';
    width: 0%;
    height: 2px;
    background: var(--base-color);
    /*Será absolute ao próximo pai dele que tiver um position relative. No caso ainda não sabia qual seria esse pai então o nav ul li a foi escolhido.*/
    position: absolute;
    left: 0;
    bottom: -1.5rem;
    transition: width 0.2s;
}

nav ul li a:hover::after {
    /*Quando ele fizer um hover usa o pseudo element after*/
    /*Ese width 100% é o que vai fazer o traço crescer no hover*/
    width: 100%;
}

nav .menu {
    /*Essa estilização é necessária para o menu que queremos fazer*/
    opacity: 0;
    visibility: hidden;
    /*As duas propriedades abaixo contribuem para a abertura suave do menu hamburguer*/
    top: -20rem;
    transition: 0.2s;
}

nav .menu ul {
    /*Para fazer cim que o menu não pisque antes de aparecer suavemente mas isso tbm faz ele sumir completamente, por isso precisamos do na.vshow .menu ul {display: grid}*/
    display: none;
}


/*Mostrar menu*/

nav.show .menu {
    /*Quando o nav tiver essa classe show, procure o menu lá dentro. Atentar para o nav estar colocado com o .show */
    opacity: 1;
    visibility: visible;
    background: var(--body-color);
    height: 100vh;
    /*Viewport é toda a altura do layout. Aqui diz "fragmenta ele em 100 pedacinhos e pega todos eles. Se aqui fosse 10vh ele pegaria apenas 10 pedacinhos de 100 do vh.*/
    width: 100vw;
    /*Esse width sozinho ñ faz com que ele pegue toda a largura do layout. Pra isso é necessário um position.*/
    position: fixed;
    top: 0;
    left: 0;
    /*Aqui diz: na page toda, fica com o top 0 e com o left 0. Daí sim ele cobre a page toda como queremos.*/
    /*Grid aqui para habilitar novas opções e uma delas é o place-content que joga os elementos bem no meio da tela*/
    display: grid;
    place-content: center;
}

nav.show .menu ul {
    /*Com isso, a abertura suave do menu contece perfeitamente*/
    display: grid;
}

nav.show ul.grid {
    /*Só vai ser grid quando tiver a class show, porque esse é apenas para o mobile*/
    /*Por questão de especificidade é necessário colocar nav ul.grid para ter o efeito desejado com a propriedade*/
    gap: 4rem;
}


/*TOGGLE MENU*/

.toggle {
    color: var(--base-color);
    font-size: 1.5rem;
    cursor: pointer;
}

nav .icon-close {
    visibility: hidden;
    opacity: 0;
    position: absolute;
    top: -1.5rem;
    right: 1.5rem;
    transition: 0.2s;
}


/* Quando clicar no botão, irá add o show ao nav. Quando isso acontecer o icon-close irá aparecer  */


/*top: -1.5rem, transition:0.2s e top: 1.5rem contribuem para uma abertura suave do menu hamburguer*/

nav.show div.icon-close {
    visibility: visible;
    opacity: 1;
    top: 1.5rem;
}


/* HOME */

#home {
    overflow: hidden;
    /*Essa propriedade faz com que os elementos ñ transbordem pelas margens mas mantenham-se nos limites do cont*/
}

#home .container {
    margin: 0;
}

#home .image {
    position: relative;
}


/* Esse pseudo element cria um elemento fantasma antes da class image */

#home .image::before {
    content: '';
    height: 100%;
    width: 100%;
    background: var(--base-color-second);
    position: absolute;
    /*Aqui tem que descolar 68px pra cima mas tem que ser transformado em porcentagem. É a alutra menos o deslocamento. Nesse caso, usa-se a regra de 3: 68 * 100 / 405 (dados tirados do layout no figma) */
    top: -9.8%;
    /* z-index é uma propriedade que está disponível por causa do uso do position (seja qual for). O eixo Z é de profundidade. Aplicando z-index: 1 aqui, quer dizer que a image tem z-index: 0 e ela fica atrás*/
    /*Esse cálculo é a largura menos o deslocamento para a direita*/
    left: 16.7%;
    z-index: 0;
    /*O top: 1-6.8% e o z-index: 0; leva o background para trás e um pouco para cima*/
}


/* "Dentro da home procura a class image e dentro dela a tag img" */

#home .image img {
    /* Esse position: relative; habilita novas funcionalidades pra usar aqui */
    position: relative;
    right: 2.93rem;
}

#home .image img,
#home .image::before {
    border-radius: 0.25rem;
}

#home .text {
    margin: 0 1.5rem;
    text-align: center;
}

#home .text h1 {
    margin-bottom: 1rem;
}

#home .text p {
    margin-bottom: 2rem;
}


/*ABOUT SESSION*/

#about {
    background: #ffffff;
}

#about .container {
    margin: 0;
}

#about .image {
    position: relative;
}

#about .image::before {
    content: '';
    height: 100%;
    width: 100%;
    background: var(--base-color-second);
    position: absolute;
    top: -8.3%;
    left: -33%;
    z-index: 0;
}

#about .image img {
    position: relative;
    right: 2.93rem;
}

#about .image img,
#about .image::before {
    border-radius: 0.25rem;
}

#about .text {
    margin: 0 1.5rem;
    text-align: center;
}


/*SERVICES SESSION*/

.cards.grid {
    gap: 1.5rem;
}

.card {
    padding: 3.625rem 2rem;
    box-shadow: 0px 0px 12px rgba(0, 0, 0, 0.08);
    border-bottom: 0.25rem solid var(--base-color);
    border-radius: 0.25rem 0.25rem 0 0;
    text-align: center;
}

.card i {
    display: block;
    margin-bottom: 1rem;
    font-size: 5rem;
    color: var(--base-color);
}

.card .title {
    font-size: 1.5rem;
}

.card .title {
    font-size: 1.5rem;
    margin-bottom: 0.75rem;
}